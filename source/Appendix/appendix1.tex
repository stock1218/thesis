\chapter{Rules on Calculating a Common Real Type}
\label{appendix:common_real_type}

The rules for calculating a common real type for a mix-typed operation are as follows \cite{c_standard}:
\begin{enumerate}
    \item If one operand has decimal floating type, the other operand shall not have standard floating, complex, or imaginary type.
    \begin{itemize}
        \item If the type of either operand is \texttt{\_Decimal128}, the other operand is converted to \texttt{\_Decimal128}.
        \item Otherwise, if the type of either operand is \texttt{\_Decimal64}, the other operand is converted to \texttt{\_Decimal64}.
        \item Otherwise, if the type of either operand is \texttt{\_Decimal32}, the other operand is converted to \texttt{\_Decimal32}.
    \end{itemize}

    \item Otherwise, if one operand is \texttt{long double}, \texttt{long double complex}, or \texttt{long double imaginary}, the other operand is implicitly converted as follows:
    \begin{itemize}
        \item Integer or real floating type to \texttt{long double}
        \item Complex type to \texttt{long double complex}
        \item Imaginary type to \texttt{long double imaginary}
    \end{itemize}

    \item Otherwise, if one operand is \texttt{double}, \texttt{double complex}, or \texttt{double imaginary}, the other operand is implicitly converted as follows:
    \begin{itemize}
        \item Integer or real floating type to \texttt{double}
        \item Complex type to \texttt{double complex}
        \item Imaginary type to \texttt{double imaginary}
    \end{itemize}

    \item Otherwise, if one operand is \texttt{float}, \texttt{float complex}, or \texttt{float imaginary}, the other operand is implicitly converted as follows:
    \begin{itemize}
        \item Integer type to \texttt{float} (the only real type possible is float, which remains as-is)
        \item Complex type remains \texttt{float complex}
        \item Imaginary type remains \texttt{float imaginary}
    \end{itemize}

    \item Otherwise, both operands are integers. Both operands undergo integer promotions; then, after promotion, one of the following applies:
    \begin{itemize}
        \item If the types are the same, that type is the common type.
        \item Else, if the types are different:
        \begin{itemize}
            \item If the types have the same signedness (both signed or both unsigned), the operand with the lesser conversion rank is implicitly converted to the other type.
            \item If the types have different signedness:
            \begin{itemize}
                \item If the unsigned type has conversion rank greater than or equal to the signed type, the signed operand is converted to the unsigned type.
                \item Else, if the signed type can represent all values of the unsigned type, the unsigned operand is converted to the signed type.
                \item Otherwise, both operands are converted to the unsigned counterpart of the signed operand's type.
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{enumerate}`

\chapter{Example Clang-tidy Config}
\label{appendix:config}
\begin{verbatim}
Checks: `-*, modernize-use-checked-arithmetic'
CheckOptions:
  - key: modernize-use-checked-arithmetic.handleCode
    value: `printf("ERROR\n");'
  - key: modernize-use-checked-arithmetic.handleImport
    value: `<stdio.h>'
\end{verbatim}
